." Text automatically generated by txt2man
.TH mpdlib 1 "22 February 2010" "" "mpd cmds"
.RS
.SH NAME
\fBmpdlib
\fB
.SH FILE
/Users/goodell/svn/mpich2-1.2.1p1-tmp/src/pm/mpd/mpdlib.py
.SH DESCRIPTION
.TP
.B
#
(C) 2001 by Argonne National Laboratory.
.TP
.B
#
See COPYRIGHT in top-level directory.
#
.SH CLASSES
\fB__builtin__.dict\fP(__builtin__.object)
MPDParmDB
__builtin__.object
MPDRing
MPDSock
MPDConClientSock
MPDListenSock
MPDConListenSock
MPDStreamHandler
MPDTest
.PP
class \fBMPDConClientSock\fP(MPDSock)
.RS
.TP
.B
|
Method resolution order:
.TP
.B
|
MPDConClientSock
.TP
.B
|
MPDSock
.TP
.B
|
__builtin__.object
.TP
.B
|
.TP
.B
|
Methods defined here:
.TP
.B
|
.TP
.B
|
\fB__init__\fP(self, name='console_to_mpd', mpdroot='', secretword='', **kargs)
.TP
.B
|
.TP
.B
|
----------------------------------------------------------------------
.TP
.B
|
Methods inherited from MPDSock:
.TP
.B
|
.TP
.B
|
\fBaccept\fP(self, name='accepter')
.TP
.B
|
.TP
.B
|
\fBclose\fP(self)
.TP
.B
|
.TP
.B
|
\fBconnect\fP(self, *args)
.TP
.B
|
.TP
.B
|
\fBfileno\fP(self)
.TP
.B
|
.TP
.B
|
\fBgetsockname\fP(self)
.TP
.B
|
.TP
.B
|
\fBrecv\fP(self, nbytes)
.TP
.B
|
.TP
.B
|
\fBrecv_char_msg\fP(self)
.TP
.B
|
.TP
.B
|
\fBrecv_dict_msg\fP(self, timeout=None)
.TP
.B
|
.TP
.B
|
\fBrecv_one_line\fP(self)
.TP
.B
|
.TP
.B
|
\fBsend_char_msg\fP(self, msg, errprint=1)
.TP
.B
|
.TP
.B
|
\fBsend_dict_msg\fP(self, msg, errprint=1)
.TP
.B
|
# The default behavior on an error needs to be to handle and/or report
.TP
.B
|
# it.  Otherwise, we all waste time trying to figure out why 
.TP
.B
|
# the code is silently failing.  I've set the default for errprint 
.TP
.B
|
# to YES rather than NO.
.TP
.B
|
.TP
.B
|
\fBsendall\fP(self, data)
.TP
.B
|
.TP
.B
|
----------------------------------------------------------------------
.TP
.B
|
Data descriptors inherited from MPDSock:
.TP
.B
|
.TP
.B
|
__dict__
.TP
.B
|
dictionary for instance variables (if defined)
.TP
.B
|
.TP
.B
|
__weakref__
.TP
.B
|
list of weak references to the object (if defined)
.RE
.PP
class \fBMPDConListenSock\fP(MPDListenSock)
.RS
.TP
.B
|
Method resolution order:
.TP
.B
|
MPDConListenSock
.TP
.B
|
MPDListenSock
.TP
.B
|
MPDSock
.TP
.B
|
__builtin__.object
.TP
.B
|
.TP
.B
|
Methods defined here:
.TP
.B
|
.TP
.B
|
\fB__init__\fP(self, name='console_listen', secretword='', **kargs)
.TP
.B
|
.TP
.B
|
----------------------------------------------------------------------
.TP
.B
|
Methods inherited from MPDSock:
.TP
.B
|
.TP
.B
|
\fBaccept\fP(self, name='accepter')
.TP
.B
|
.TP
.B
|
\fBclose\fP(self)
.TP
.B
|
.TP
.B
|
\fBconnect\fP(self, *args)
.TP
.B
|
.TP
.B
|
\fBfileno\fP(self)
.TP
.B
|
.TP
.B
|
\fBgetsockname\fP(self)
.TP
.B
|
.TP
.B
|
\fBrecv\fP(self, nbytes)
.TP
.B
|
.TP
.B
|
\fBrecv_char_msg\fP(self)
.TP
.B
|
.TP
.B
|
\fBrecv_dict_msg\fP(self, timeout=None)
.TP
.B
|
.TP
.B
|
\fBrecv_one_line\fP(self)
.TP
.B
|
.TP
.B
|
\fBsend_char_msg\fP(self, msg, errprint=1)
.TP
.B
|
.TP
.B
|
\fBsend_dict_msg\fP(self, msg, errprint=1)
.TP
.B
|
# The default behavior on an error needs to be to handle and/or report
.TP
.B
|
# it.  Otherwise, we all waste time trying to figure out why 
.TP
.B
|
# the code is silently failing.  I've set the default for errprint 
.TP
.B
|
# to YES rather than NO.
.TP
.B
|
.TP
.B
|
\fBsendall\fP(self, data)
.TP
.B
|
.TP
.B
|
----------------------------------------------------------------------
.TP
.B
|
Data descriptors inherited from MPDSock:
.TP
.B
|
.TP
.B
|
__dict__
.TP
.B
|
dictionary for instance variables (if defined)
.TP
.B
|
.TP
.B
|
__weakref__
.TP
.B
|
list of weak references to the object (if defined)
.RE
.PP
class \fBMPDListenSock\fP(MPDSock)
.RS
.TP
.B
|
Method resolution order:
.TP
.B
|
MPDListenSock
.TP
.B
|
MPDSock
.TP
.B
|
__builtin__.object
.TP
.B
|
.TP
.B
|
Methods defined here:
.TP
.B
|
.TP
.B
|
\fB__init__\fP(self, host='', port=0, filename='', listen=5, name='listener', **kargs)
.TP
.B
|
.TP
.B
|
----------------------------------------------------------------------
.TP
.B
|
Methods inherited from MPDSock:
.TP
.B
|
.TP
.B
|
\fBaccept\fP(self, name='accepter')
.TP
.B
|
.TP
.B
|
\fBclose\fP(self)
.TP
.B
|
.TP
.B
|
\fBconnect\fP(self, *args)
.TP
.B
|
.TP
.B
|
\fBfileno\fP(self)
.TP
.B
|
.TP
.B
|
\fBgetsockname\fP(self)
.TP
.B
|
.TP
.B
|
\fBrecv\fP(self, nbytes)
.TP
.B
|
.TP
.B
|
\fBrecv_char_msg\fP(self)
.TP
.B
|
.TP
.B
|
\fBrecv_dict_msg\fP(self, timeout=None)
.TP
.B
|
.TP
.B
|
\fBrecv_one_line\fP(self)
.TP
.B
|
.TP
.B
|
\fBsend_char_msg\fP(self, msg, errprint=1)
.TP
.B
|
.TP
.B
|
\fBsend_dict_msg\fP(self, msg, errprint=1)
.TP
.B
|
# The default behavior on an error needs to be to handle and/or report
.TP
.B
|
# it.  Otherwise, we all waste time trying to figure out why 
.TP
.B
|
# the code is silently failing.  I've set the default for errprint 
.TP
.B
|
# to YES rather than NO.
.TP
.B
|
.TP
.B
|
\fBsendall\fP(self, data)
.TP
.B
|
.TP
.B
|
----------------------------------------------------------------------
.TP
.B
|
Data descriptors inherited from MPDSock:
.TP
.B
|
.TP
.B
|
__dict__
.TP
.B
|
dictionary for instance variables (if defined)
.TP
.B
|
.TP
.B
|
__weakref__
.TP
.B
|
list of weak references to the object (if defined)
.RE
.PP
class \fBMPDParmDB\fP(__builtin__.dict)
.RS
.TP
.B
|
Method resolution order:
.TP
.B
|
MPDParmDB
.TP
.B
|
__builtin__.dict
.TP
.B
|
__builtin__.object
.TP
.B
|
.TP
.B
|
Methods defined here:
.TP
.B
|
.TP
.B
|
\fB__getitem__\fP(self, key)
.TP
.B
|
.TP
.B
|
\fB__init__\fP(self, orderedSources=[])
.TP
.B
|
.TP
.B
|
\fB__setitem__\fP(self, sk_tup, val)
.TP
.B
|
.TP
.B
|
\fBget_parms_from_env\fP(self, parmsToOverride)
.TP
.B
|
.TP
.B
|
\fBget_parms_from_rcfile\fP(self, parmsToOverride, errIfMissingFile=0)
.TP
.B
|
.TP
.B
|
\fBhas_key\fP(self, key)
.TP
.B
|
.TP
.B
|
\fBprintall\fP(self)
.TP
.B
|
.TP
.B
|
\fBprintdef\fP(self)
.TP
.B
|
.TP
.B
|
----------------------------------------------------------------------
.TP
.B
|
Data descriptors defined here:
.TP
.B
|
.TP
.B
|
__dict__
.TP
.B
|
dictionary for instance variables (if defined)
.TP
.B
|
.TP
.B
|
__weakref__
.TP
.B
|
list of weak references to the object (if defined)
.TP
.B
|
.TP
.B
|
----------------------------------------------------------------------
.TP
.B
|
Methods inherited from __builtin__.dict:
.TP
.B
|
.TP
.B
|
\fB__cmp__\fP(\.\.\.)
.TP
.B
|
\fBx.__cmp__\fP(y) <==> \fBcmp\fP(x,y)
.TP
.B
|
.TP
.B
|
\fB__contains__\fP(\.\.\.)
.TP
.B
|
\fBD.__contains__\fP(k) -> True if D has a key k, else False
.TP
.B
|
.TP
.B
|
\fB__delitem__\fP(\.\.\.)
.TP
.B
|
\fBx.__delitem__\fP(y) <==> del x[y]
.TP
.B
|
.TP
.B
|
\fB__eq__\fP(\.\.\.)
.TP
.B
|
\fBx.__eq__\fP(y) <==> x==y
.TP
.B
|
.TP
.B
|
\fB__ge__\fP(\.\.\.)
.TP
.B
|
\fBx.__ge__\fP(y) <==> x>=y
.TP
.B
|
.TP
.B
|
\fB__getattribute__\fP(\.\.\.)
.TP
.B
|
\fBx.__getattribute__\fP('name') <==> x.name
.TP
.B
|
.TP
.B
|
\fB__gt__\fP(\.\.\.)
.TP
.B
|
\fBx.__gt__\fP(y) <==> x>y
.TP
.B
|
.TP
.B
|
\fB__hash__\fP(\.\.\.)
.TP
.B
|
\fBx.__hash__\fP() <==> \fBhash\fP(x)
.TP
.B
|
.TP
.B
|
\fB__iter__\fP(\.\.\.)
.TP
.B
|
\fBx.__iter__\fP() <==> \fBiter\fP(x)
.TP
.B
|
.TP
.B
|
\fB__le__\fP(\.\.\.)
.TP
.B
|
\fBx.__le__\fP(y) <==> x<=y
.TP
.B
|
.TP
.B
|
\fB__len__\fP(\.\.\.)
.TP
.B
|
\fBx.__len__\fP() <==> \fBlen\fP(x)
.TP
.B
|
.TP
.B
|
\fB__lt__\fP(\.\.\.)
.TP
.B
|
\fBx.__lt__\fP(y) <==> x<y
.TP
.B
|
.TP
.B
|
\fB__ne__\fP(\.\.\.)
.TP
.B
|
\fBx.__ne__\fP(y) <==> x!=y
.TP
.B
|
.TP
.B
|
\fB__repr__\fP(\.\.\.)
.TP
.B
|
\fBx.__repr__\fP() <==> \fBrepr\fP(x)
.TP
.B
|
.TP
.B
|
\fBclear\fP(\.\.\.)
.TP
.B
|
\fBD.clear\fP() -> None.  Remove all items from D.
.TP
.B
|
.TP
.B
|
\fBcopy\fP(\.\.\.)
.TP
.B
|
\fBD.copy\fP() -> a shallow copy of D
.TP
.B
|
.TP
.B
|
\fBget\fP(\.\.\.)
.TP
.B
|
\fBD.get\fP(k[,d]) -> D[k] if k in D, else d.  d defaults to None.
.TP
.B
|
.TP
.B
|
\fBitems\fP(\.\.\.)
.TP
.B
|
\fBD.items\fP() -> list of D's (key, value) pairs, as 2-tuples
.TP
.B
|
.TP
.B
|
\fBiteritems\fP(\.\.\.)
.TP
.B
|
\fBD.iteritems\fP() -> an iterator over the (key, value) items of D
.TP
.B
|
.TP
.B
|
\fBiterkeys\fP(\.\.\.)
.TP
.B
|
\fBD.iterkeys\fP() -> an iterator over the keys of D
.TP
.B
|
.TP
.B
|
\fBitervalues\fP(\.\.\.)
.TP
.B
|
\fBD.itervalues\fP() -> an iterator over the values of D
.TP
.B
|
.TP
.B
|
\fBkeys\fP(\.\.\.)
.TP
.B
|
\fBD.keys\fP() -> list of D's keys
.TP
.B
|
.TP
.B
|
\fBpop\fP(\.\.\.)
.TP
.B
|
\fBD.pop\fP(k[,d]) -> v, remove specified key and return the corresponding value
.TP
.B
|
If key is not found, d is returned if given, otherwise KeyError is raised
.TP
.B
|
.TP
.B
|
\fBpopitem\fP(\.\.\.)
.TP
.B
|
\fBD.popitem\fP() -> (k, v), remove and return some (key, value) pair as a
.TP
.B
|
2-tuple; but raise KeyError if D is empty
.TP
.B
|
.TP
.B
|
\fBsetdefault\fP(\.\.\.)
.TP
.B
|
\fBD.setdefault\fP(k[,d]) -> \fBD.get\fP(k,d), also set D[k]=d if k not in D
.TP
.B
|
.TP
.B
|
\fBupdate\fP(\.\.\.)
.TP
.B
|
\fBD.update\fP(E, **F) -> None.  Update D from E and F: for k in E: D[k] = E[k]
.TP
.B
|
(if E has keys else: for (k, v) in E: D[k] = v) then: for k in F: D[k] = F[k]
.TP
.B
|
.TP
.B
|
\fBvalues\fP(\.\.\.)
.TP
.B
|
\fBD.values\fP() -> list of D's values
.TP
.B
|
.TP
.B
|
----------------------------------------------------------------------
.TP
.B
|
Data and other attributes inherited from __builtin__.dict:
.TP
.B
|
.TP
.B
|
__new__ = <built-in method __new__ of type object at 0x1eeec0>
.TP
.B
|
\fBT.__new__\fP(S, \.\.\.) -> a new object with type S, a subtype of T
.TP
.B
|
.TP
.B
|
fromkeys = <built-in method fromkeys of type object at 0x339390>
.TP
.B
|
\fBdict.fromkeys\fP(S[,v]) -> New dict with keys from S and values equal to v.
.TP
.B
|
v defaults to None.
.RE
.PP
class \fBMPDRing\fP(__builtin__.object)
.RS
.TP
.B
|
Methods defined here:
.TP
.B
|
.TP
.B
|
\fB__init__\fP(self, listenSock=None, streamHandler=None, secretword='', myIfhn='', entryIfhn='', entryPort=0, zcMyLevel=0)
.TP
.B
|
.TP
.B
|
\fBaccept_lhs\fP(self, lhsHandler=None)
.TP
.B
|
.TP
.B
|
\fBaccept_rhs\fP(self, rhsHandler=None)
.TP
.B
|
.TP
.B
|
\fBconnect_lhs\fP(self, lhsIfhn='', lhsPort=0, lhsHandler=None, numTries=1)
.TP
.B
|
.TP
.B
|
\fBconnect_rhs\fP(self, rhsIfhn='', rhsPort=0, rhsHandler=None, numTries=1)
.TP
.B
|
.TP
.B
|
\fBcreate_single_mem_ring\fP(self, ifhn='', port=0, lhsHandler=None, rhsHandler=None)
.TP
.B
|
.TP
.B
|
\fBenter_ring\fP(self, entryIfhn='', entryPort=0, lhsHandler='', rhsHandler='', ntries=1)
.TP
.B
|
.TP
.B
|
\fBhandle_lhs_challenge_response\fP(self, sock)
.TP
.B
|
.TP
.B
|
\fBhandle_rhs_challenge_response\fP(self, sock)
.TP
.B
|
.TP
.B
|
\fBhandle_ring_listener_connection\fP(self, sock)
.TP
.B
|
.TP
.B
|
\fBreenter_ring\fP(self, entryIfhn='', entryPort=0, lhsHandler='', rhsHandler='', ntries=5)
.TP
.B
|
.TP
.B
|
----------------------------------------------------------------------
.TP
.B
|
Data descriptors defined here:
.TP
.B
|
.TP
.B
|
__dict__
.TP
.B
|
dictionary for instance variables (if defined)
.TP
.B
|
.TP
.B
|
__weakref__
.TP
.B
|
list of weak references to the object (if defined)
.RE
.PP
class \fBMPDSock\fP(__builtin__.object)
.RS
.TP
.B
|
Methods defined here:
.TP
.B
|
.TP
.B
|
\fB__init__\fP(self, family=2, socktype=1, proto=0, sock=None, name='')
.TP
.B
|
.TP
.B
|
\fBaccept\fP(self, name='accepter')
.TP
.B
|
.TP
.B
|
\fBclose\fP(self)
.TP
.B
|
.TP
.B
|
\fBconnect\fP(self, *args)
.TP
.B
|
.TP
.B
|
\fBfileno\fP(self)
.TP
.B
|
.TP
.B
|
\fBgetsockname\fP(self)
.TP
.B
|
.TP
.B
|
\fBrecv\fP(self, nbytes)
.TP
.B
|
.TP
.B
|
\fBrecv_char_msg\fP(self)
.TP
.B
|
.TP
.B
|
\fBrecv_dict_msg\fP(self, timeout=None)
.TP
.B
|
.TP
.B
|
\fBrecv_one_line\fP(self)
.TP
.B
|
.TP
.B
|
\fBsend_char_msg\fP(self, msg, errprint=1)
.TP
.B
|
.TP
.B
|
\fBsend_dict_msg\fP(self, msg, errprint=1)
.TP
.B
|
# The default behavior on an error needs to be to handle and/or report
.TP
.B
|
# it.  Otherwise, we all waste time trying to figure out why 
.TP
.B
|
# the code is silently failing.  I've set the default for errprint 
.TP
.B
|
# to YES rather than NO.
.TP
.B
|
.TP
.B
|
\fBsendall\fP(self, data)
.TP
.B
|
.TP
.B
|
----------------------------------------------------------------------
.TP
.B
|
Data descriptors defined here:
.TP
.B
|
.TP
.B
|
__dict__
.TP
.B
|
dictionary for instance variables (if defined)
.TP
.B
|
.TP
.B
|
__weakref__
.TP
.B
|
list of weak references to the object (if defined)
.RE
.PP
class \fBMPDStreamHandler\fP(__builtin__.object)
.RS
.TP
.B
|
Methods defined here:
.TP
.B
|
.TP
.B
|
\fB__init__\fP(self)
.TP
.B
|
.TP
.B
|
\fBclose_all_active_streams\fP(self)
.TP
.B
|
.TP
.B
|
\fBdel_handler\fP(self, stream)
.TP
.B
|
.TP
.B
|
\fBhandle_active_streams\fP(self, streams=None, timeout=0.10000000000000001)
.TP
.B
|
.TP
.B
|
\fBset_handler\fP(self, stream, handler, \fBargs=\fP())
.TP
.B
|
.TP
.B
|
----------------------------------------------------------------------
.TP
.B
|
Data descriptors defined here:
.TP
.B
|
.TP
.B
|
__dict__
.TP
.B
|
dictionary for instance variables (if defined)
.TP
.B
|
.TP
.B
|
__weakref__
.TP
.B
|
list of weak references to the object (if defined)
.RE
.PP
class \fBMPDTest\fP(__builtin__.object)
.RS
.TP
.B
|
Methods defined here:
.TP
.B
|
.TP
.B
|
\fB__init__\fP(self)
.TP
.B
|
.TP
.B
|
\fBrun\fP(self, cmd='', expIn='', chkEC=0, expEC=0, chkOut=0, expOut='', ordOut=0, grepOut=0, exitOnFail=1)
.TP
.B
|
.TP
.B
|
----------------------------------------------------------------------
.TP
.B
|
Data descriptors defined here:
.TP
.B
|
.TP
.B
|
__dict__
.TP
.B
|
dictionary for instance variables (if defined)
.TP
.B
|
.TP
.B
|
__weakref__
.TP
.B
|
list of weak references to the object (if defined)
.SH FUNCTIONS
\fBdumps\fP(\.\.\.)
\fBdumps\fP(obj, protocol=0) -- Return a string containing an object in pickle format.
.RS
.PP
See the Pickler docstring for the meaning of optional argument proto.
.RE
.PP
\fBloads\fP(\.\.\.)
\fBloads\fP(string) -- Load a pickle from the given string
.PP
md5new = \fBopenssl_md5\fP(\.\.\.)
Returns a md5 hash object; optionally initialized with a string
.PP
\fBmpd_check_python_version\fP()
.PP
\fBmpd_close_zc\fP()
.PP
\fBmpd_find_zc_peer\fP(peer_level)
.PP
\fBmpd_get_groups_for_username\fP(username)
.PP
\fBmpd_get_my_id\fP()
.PP
\fBmpd_get_my_username\fP()
.PP
\fBmpd_get_ranks_in_binary_tree\fP(myRank, nprocs)
.PP
\fBmpd_handle_signal\fP(signum, frame)
.PP
\fBmpd_init_zc\fP(ifhn, my_level)
#### experimental code for zeroconf
.PP
\fBmpd_print\fP(*args)
.PP
\fBmpd_print_tb\fP(*args)
.PP
\fBmpd_read_nbytes\fP(fd, nbytes)
.PP
\fBmpd_register_zc\fP(ifhn, level)
.PP
\fBmpd_same_ips\fP(host1, host2)
.PP
\fBmpd_set_cli_app\fP(app)
.PP
\fBmpd_set_dbg_level\fP(flag)
.PP
\fBmpd_set_my_id\fP(myid='')
.PP
\fBmpd_set_procedures_to_trace\fP(procs)
.PP
\fBmpd_set_tmpdir\fP(tmpdir)
.PP
\fBmpd_sockpair\fP()
.PP
\fBmpd_trace_calls\fP(frame, event, args)
.PP
\fBmpd_trace_returns\fP(frame, event, args)
.PP
\fBmpd_uncaught_except_tb\fP(arg1, arg2, arg3)
.PP
\fBmpd_version\fP()
.PP
\fBmpd_which\fP(execName, user_path=None)
.PP
\fBrandom\fP(\.\.\.)
\fBrandom\fP() -> x in the interval [0, 1).
.PP
\fBsleep\fP(\.\.\.)
\fBsleep\fP(seconds)
.RS
.TP
.B
Delay execution for a given number of seconds.
The argument may be
a floating point number for subsecond precision.
.SH DATA
ECONNREFUSED = 61
ECONNRESET = 54
EINTR = 4
EISCONN = 56
EPIPE = 32
grp_module_available = 1
mpd_cli_app = ''
mpd_dbg_level = 0
mpd_my_hostname = ''
mpd_my_id = ''
mpd_procedures_to_trace = []
mpd_signum = 0
mpd_tmpdir = '/tmp'
mpd_zc = 0
pwd_module_available = 1
subprocess_module_available = 1
syslog_module_available = 1
.RE
.PP

