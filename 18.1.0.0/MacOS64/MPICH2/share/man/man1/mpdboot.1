." Text automatically generated by txt2man
.TH mpdboot 1 "22 February 2010" "" "mpd cmds"
.RS
.SH NAME
\fBmpdboot
\fB
.SH FILE
/Users/goodell/svn/mpich2-1.2.1p1-tmp/src/pm/mpd/mpdboot.py
.SH DESCRIPTION
.TP
.B
usage:
mpdboot \fB--totalnum\fP=<n_to_start> [\fB--file\fP=<hostsfile>]  [\fB--help\fP] \ 
.RS
.TP
.B
[\fB--rsh\fP=<rshcmd>] [\fB--user\fP=<user>] [\fB--mpd\fP=<mpdcmd>]
\ 
.TP
.B
[\fB--loccons\fP] [\fB--remcons\fP] [\fB--shell\fP] [\fB--verbose\fP] [\fB-1\fP]
[\fB--ncpus\fP=<ncpus>] [\fB--ifhn\fP=<ifhn>] [\fB--chkup\fP] [\fB--chkuponly\fP]                 [\fB--maxbranch\fP=<maxbranch>]
or, in short form, 
mpdboot \fB-n\fP n_to_start [\fB-f\fP <hostsfile>] [\fB-h\fP] [\fB-r\fP <rshcmd>] [\fB-u\fP <user>] \ 
.TP
.B
[\fB-m\fP <mpdcmd>]
\fB-s\fP \fB-v\fP [\fB-1\fP] [\fB-c\fP]
.RE
.PP
\fB--totalnum\fP specifies the total number of mpds to start; at least
one mpd will be started locally, and others on the machines specified
by the file argument; by default, only one mpd per host will be
started even if the hostname occurs multiple times in the hosts file
\fB-1\fP means remove the restriction of starting only one mpd per machine; 
in this case, at most the first mpd on a host will have a console
\fB--file\fP specifies the file of machines to start the rest of the mpds on;
it defaults to mpd.hosts
\fB--mpd\fP specifies the full path name of mpd on the remote hosts if it is
not in your path
\fB--rsh\fP specifies the name of the command used to start remote mpds; it
defaults to ssh; an alternative is rsh
\fB--shell\fP says that the Bourne shell is your default for rsh' 
\fB--verbose\fP shows the ssh attempts as they occur; it does not provide
confirmation that the sshs were successful
\fB--loccons\fP says you do not want a console available on local \fBmpd\fP(s)
\fB--remcons\fP says you do not want consoles available on remote \fBmpd\fP(s)
\fB--ncpus\fP indicates how many cpus you want to show for the local machine;
others are listed in the hosts file
\fB--ifhn\fP indicates the interface hostname to use for the local mpd; others
may be specified in the hostsfile
\fB--chkup\fP requests that mpdboot try to verify that the hosts in the host file
are up before attempting start mpds on any of them; it just checks the number
of hosts specified by \fB-n\fP
\fB--chkuponly\fP requests that mpdboot try to verify that the hosts in the host file
are up; it then terminates; it just checks the number of hosts specified by \fB-n\fP
\fB--maxbranch\fP indicates the maximum number of mpds to enter the ring under another;
the default is 4
.SH FUNCTIONS
\fBaccess\fP(\.\.\.)
\fBaccess\fP(path, mode) -> True if granted, False otherwise
.RS
.TP
.B
Use the real uid/gid to test for access to a path.
Note that most
operations will use the effective uid/gid, therefore this routine can
be used in a suid/sgid environment to test if the invoking user has the
.TP
.B
specified access to the path.
The mode argument can be F_OK to test
existence, or the inclusive-OR of R_OK, W_OK, and X_OK.
.RE
.PP
\fBchkupdn\fP(hostList)
.PP
\fBctime\fP(\.\.\.)
\fBctime\fP(seconds) -> string
.RS
.PP
Convert a time in seconds since the Epoch to a string in local time.
This is equivalent to \fBasctime\fP(localtime(seconds)). When the time tuple is
not present, current time as returned by \fBlocaltime\fP() is used.
.RE
.PP
\fBexit\fP(\.\.\.)
\fBexit\fP([status])
.RS
.PP
Exit the interpreter by raising \fBSystemExit\fP(status).
If the status is omitted or None, it defaults to zero (i.e., success).
If the status is numeric, it will be used as the system exit status.
If it is another kind of object, it will be printed and the system
exit status will be one (i.e., failure).
.RE
.PP
\fBgethostbyname_ex\fP(\.\.\.)
\fBgethostbyname_ex\fP(host) -> (name, aliaslist, addresslist)
.RS
.PP
Return the true host name, a list of aliases, and a list of IP addresses,
.TP
.B
for a host.
The host argument is a string giving a host name or IP number.
.RE
.PP
\fBgethostname\fP(\.\.\.)
\fBgethostname\fP() -> string
.RS
.PP
Return the current host name.
.RE
.PP
\fBhandle_mpd_output\fP(fd, fd2idx, hostsAndInfo)
.PP
\fBkill\fP(\.\.\.)
\fBkill\fP(pid, sig)
.RS
.PP
Kill a process with a signal.
.RE
.PP
\fBlaunch_one_mpd\fP(idxToStart, currRoot, mpdArgs, hostsAndInfo)
.PP
\fBmpdboot\fP()
.PP
\fBselect\fP(\.\.\.)
\fBselect\fP(rlist, wlist, xlist[, timeout]) -> (rlist, wlist, xlist)
.RS
.PP
Wait until one or more file descriptors are ready for some kind of I/O.
The first three arguments are sequences of file descriptors to be waited for:
rlist -- wait until ready for reading
wlist -- wait until ready for writing
xlist -- wait for an ``exceptional condition''
If only one kind of condition is required, pass [] for the other lists.
A file descriptor is either a socket or file object, or a small integer
gotten from a \fBfileno\fP() method call on one of those.
.PP
The optional 4th argument specifies a timeout in seconds; it may be
.TP
.B
a floating point number to specify fractions of seconds.
If it is absent
or None, the call will never time out.
.PP
The return value is a tuple of three lists corresponding to the first three
arguments; each contains the subset of the corresponding file descriptors
that are ready.
.PP
*** IMPORTANT NOTICE ***
On Windows and OpenVMS, only sockets are supported; on Unix, all file descriptors.
.RE
.PP
\fBusage\fP()
.SH DATA
SIGKILL = 9
X_OK = 1
__author__ = 'Ralph Butler and Rusty Lusk'
__credits__ = ''
__date__ = 'Mon Feb 22 16:28:11 2010'
__version__ = '$Revision: 1.49 $'
argv = ['/usr/bin/pydoc', 'mpdboot']
environ = {'_': '/usr/bin/pydoc', 'HOME': '/Users/goodell'\.\.\.=00;36:*....
stdout = <open file '<stdout>', mode 'w' at 0x17068>
.SH VERSION
1.49
.SH DATE
Mon Feb 22 16:28:11 2010
.SH AUTHOR
Ralph Butler and Rusty Lusk
.SH CREDITS



